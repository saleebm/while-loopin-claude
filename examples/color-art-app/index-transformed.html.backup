<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Generative Color Art Playground</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Monaco', 'Courier New', monospace;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
      color: #fff;
      overflow: hidden;
      height: 100vh;
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
    }

    #ui-panel {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.85);
      border: 1px solid rgba(0, 255, 255, 0.3);
      border-radius: 8px;
      padding: 20px;
      min-width: 280px;
      max-height: 90vh;
      overflow-y: auto;
      backdrop-filter: blur(10px);
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
      z-index: 10;
    }

    #ui-panel h2 {
      font-size: 16px;
      margin-bottom: 15px;
      color: #0ff;
      text-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
    }

    #ui-panel h3 {
      font-size: 12px;
      margin-top: 15px;
      margin-bottom: 8px;
      color: #0ff;
      opacity: 0.8;
    }

    .pattern-name {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 5px;
      color: #fff;
      text-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
    }

    .seed-code {
      font-size: 10px;
      color: rgba(255, 255, 255, 0.5);
      margin-bottom: 10px;
    }

    .color-palette {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-bottom: 15px;
    }

    .color-swatch {
      height: 40px;
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      position: relative;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .color-swatch:hover {
      transform: scale(1.05);
    }

    .color-info {
      position: absolute;
      bottom: 2px;
      left: 4px;
      font-size: 8px;
      background: rgba(0, 0, 0, 0.7);
      padding: 2px 4px;
      border-radius: 2px;
      white-space: nowrap;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    button {
      background: rgba(0, 255, 255, 0.15);
      border: 1px solid rgba(0, 255, 255, 0.4);
      color: #0ff;
      padding: 10px 15px;
      cursor: pointer;
      font-family: inherit;
      font-size: 11px;
      border-radius: 4px;
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    button:hover {
      background: rgba(0, 255, 255, 0.25);
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
      transform: translateY(-2px);
    }

    button:active {
      transform: translateY(0);
    }

    .slider-container {
      margin: 8px 0;
    }

    .slider-label {
      font-size: 10px;
      color: rgba(255, 255, 255, 0.7);
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
    }

    input[type="range"] {
      width: 100%;
      height: 4px;
      border-radius: 2px;
      background: rgba(0, 255, 255, 0.2);
      outline: none;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #0ff;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
    }

    input[type="range"]::-moz-range-thumb {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #0ff;
      cursor: pointer;
      border: none;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
    }

    .fps-counter {
      font-size: 10px;
      color: rgba(255, 255, 255, 0.5);
      margin-top: 10px;
    }

    .keyboard-hint {
      position: absolute;
      bottom: 20px;
      left: 20px;
      font-size: 10px;
      color: rgba(255, 255, 255, 0.4);
      background: rgba(0, 0, 0, 0.7);
      padding: 10px 15px;
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .keyboard-hint div {
      margin: 3px 0;
    }

    @media (max-width: 768px) {
      #ui-panel {
        top: 10px;
        right: 10px;
        min-width: 240px;
        padding: 15px;
      }

      .keyboard-hint {
        display: none;
      }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div id="ui-panel">
    <h2>ðŸŽ¨ GENERATIVE ART</h2>
    <div class="pattern-name" id="pattern-name">Loading...</div>
    <div class="seed-code" id="seed-code">Seed: ...</div>

    <h3>COLOR PALETTE</h3>
    <div class="color-palette" id="color-palette"></div>

    <h3>PATTERN</h3>
    <div class="controls">
      <button onclick="art.nextPattern()">Next Pattern</button>
      <button onclick="art.randomize()">Randomize</button>
      <button onclick="art.toggleAnimation()">Pause/Play</button>
      <button onclick="art.exportImage()">Export PNG</button>
    </div>

    <h3>PARAMETERS</h3>
    <div class="slider-container">
      <div class="slider-label">
        <span>Speed</span>
        <span id="speed-value">1.0</span>
      </div>
      <input type="range" id="speed-slider" min="0.1" max="3" step="0.1" value="1"
             oninput="art.setSpeed(this.value)">
    </div>

    <div class="slider-container">
      <div class="slider-label">
        <span>Density</span>
        <span id="density-value">1.0</span>
      </div>
      <input type="range" id="density-slider" min="0.2" max="2" step="0.1" value="1"
             oninput="art.setDensity(this.value)">
    </div>

    <div class="slider-container">
      <div class="slider-label">
        <span>Complexity</span>
        <span id="complexity-value">1.0</span>
      </div>
      <input type="range" id="complexity-slider" min="0.5" max="2" step="0.1" value="1"
             oninput="art.setComplexity(this.value)">
    </div>

    <div class="fps-counter" id="fps-counter">FPS: 60</div>
  </div>

  <div class="keyboard-hint">
    <div><strong>SPACE</strong> - Next Pattern</div>
    <div><strong>R</strong> - Randomize</div>
    <div><strong>P</strong> - Pause/Play</div>
    <div><strong>E</strong> - Export</div>
    <div><strong>CLICK/DRAG</strong> - Interact</div>
  </div>

  <script>
    // ============================================================================
    // COLOR PALETTE SYSTEM
    // ============================================================================

    class ColorPalette {
      constructor(baseHue = null, scheme = 'analogous', seed = null) {
        this.seed = seed || Math.random();
        this.random = this.seededRandom(this.seed);
        this.baseHue = baseHue !== null ? baseHue : this.random() * 360;
        this.scheme = scheme;
        this.colors = this.generatePalette();
      }

      seededRandom(seed) {
        return function() {
          seed = (seed * 9301 + 49297) % 233280;
          return seed / 233280;
        };
      }

      generatePalette() {
        const schemes = {
          analogous: () => {
            return [0, 30, 60, 330].map(offset =>
              this.createColor((this.baseHue + offset) % 360, 70, 60)
            );
          },
          complementary: () => {
            return [0, 180, 15, 195].map(offset =>
              this.createColor((this.baseHue + offset) % 360, 75, 55)
            );
          },
          triadic: () => {
            return [0, 120, 240, 60].map(offset =>
              this.createColor((this.baseHue + offset) % 360, 80, 60)
            );
          },
          tetradic: () => {
            return [0, 90, 180, 270].map(offset =>
              this.createColor((this.baseHue + offset) % 360, 70, 58)
            );
          },
          monochromatic: () => {
            return [0, 0, 0, 0].map((_, i) =>
              this.createColor(this.baseHue, 75 - i * 10, 40 + i * 15)
            );
          },
          cosmic: () => {
            return [270, 300, 180, 330].map(offset =>
              this.createColor((this.baseHue + offset) % 360, 85, 55)
            );
          },
          vaporwave: () => {
            const hues = [300, 180, 270, 330];
            return hues.map(h => this.createColor(h, 90, 65));
          },
          cyberpunk: () => {
            const hues = [330, 180, 60, 280];
            return hues.map(h => this.createColor(h, 100, 50));
          }
        };

        const generator = schemes[this.scheme] || schemes.analogous;
        return generator();
      }

      createColor(hue, saturation, lightness) {
        return {
          h: Math.round(hue),
          s: Math.round(saturation),
          l: Math.round(lightness),
          a: 1
        };
      }

      getColor(index, alpha = 1) {
        const color = this.colors[index % this.colors.length];
        return `hsla(${color.h}, ${color.s}%, ${color.l}%, ${alpha})`;
      }

      toHex(hsla) {
        const match = hsla.match(/hsla?\((\d+),\s*(\d+)%,\s*(\d+)%/);
        if (!match) return '#000000';

        const h = parseInt(match[1]) / 360;
        const s = parseInt(match[2]) / 100;
        const l = parseInt(match[3]) / 100;

        let r, g, b;
        if (s === 0) {
          r = g = b = l;
        } else {
          const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
          };
          const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          const p = 2 * l - q;
          r = hue2rgb(p, q, h + 1/3);
          g = hue2rgb(p, q, h);
          b = hue2rgb(p, q, h - 1/3);
        }

        const toHex = x => {
          const hex = Math.round(x * 255).toString(16);
          return hex.length === 1 ? '0' + hex : hex;
        };

        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
      }

      getAllColors() {
        return this.colors;
      }
    }

    // ============================================================================
    // GENERATIVE ART PATTERNS
    // ============================================================================

    class FlowFieldPattern {
      constructor(ctx, width, height, palette) {
        this.ctx = ctx;
        this.width = width;
        this.height = height;
        this.palette = palette;
        this.particles = [];
        this.time = 0;
        this.density = 1;

        this.initParticles();
      }

      initParticles() {
        this.particles = [];
        const count = Math.floor(800 * this.density);
        for (let i = 0; i < count; i++) {
          this.particles.push({
            x: Math.random() * this.width,
            y: Math.random() * this.height,
            vx: 0,
            vy: 0,
            life: Math.random(),
            colorIndex: Math.floor(Math.random() * 4)
          });
        }
      }

      update(speed, complexity) {
        this.time += 0.005 * speed;

        this.particles.forEach(p => {
          const angle = this.getFlowAngle(p.x, p.y, complexity);
          const force = 0.5;
          p.vx += Math.cos(angle) * force;
          p.vy += Math.sin(angle) * force;
          p.vx *= 0.95;
          p.vy *= 0.95;

          p.x += p.vx * speed;
          p.y += p.vy * speed;

          if (p.x < 0 || p.x > this.width || p.y < 0 || p.y > this.height) {
            p.x = Math.random() * this.width;
            p.y = Math.random() * this.height;
            p.vx = 0;
            p.vy = 0;
          }

          p.life = (p.life + 0.002) % 1;
        });
      }

      getFlowAngle(x, y, complexity) {
        const scale = 0.003 * complexity;
        return Math.sin(x * scale + this.time) * Math.cos(y * scale + this.time) * Math.PI * 2;
      }

      draw() {
        this.ctx.globalCompositeOperation = 'lighter';

        this.particles.forEach(p => {
          const alpha = Math.sin(p.life * Math.PI) * 0.6;
          this.ctx.fillStyle = this.palette.getColor(p.colorIndex, alpha);
          this.ctx.beginPath();
          this.ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
          this.ctx.fill();
        });

        this.ctx.globalCompositeOperation = 'source-over';
      }
    }

    class FractalTreePattern {
      constructor(ctx, width, height, palette) {
        this.ctx = ctx;
        this.width = width;
        this.height = height;
        this.palette = palette;
        this.time = 0;
        this.complexity = 1;
      }

      update(speed, complexity) {
        this.time += 0.01 * speed;
        this.complexity = complexity;
      }

      draw() {
        const branches = Math.floor(5 * this.complexity);
        for (let i = 0; i < branches; i++) {
          const angle = (i / branches) * Math.PI * 2 + this.time;
          const startX = this.width / 2;
          const startY = this.height / 2;

          this.drawBranch(startX, startY, angle, 100, 0, i);
        }
      }

      drawBranch(x, y, angle, length, depth, colorIndex) {
        if (depth > 6 || length < 2) return;

        const endX = x + Math.cos(angle) * length;
        const endY = y + Math.sin(angle) * length;

        const alpha = 1 - depth / 7;
        this.ctx.strokeStyle = this.palette.getColor(colorIndex % 4, alpha * 0.8);
        this.ctx.lineWidth = Math.max(1, 8 - depth);
        this.ctx.lineCap = 'round';

        this.ctx.beginPath();
        this.ctx.moveTo(x, y);
        this.ctx.lineTo(endX, endY);
        this.ctx.stroke();

        const angleOffset = Math.sin(this.time + depth) * 0.3;
        this.drawBranch(endX, endY, angle - 0.4 + angleOffset, length * 0.7, depth + 1, colorIndex);
        this.drawBranch(endX, endY, angle + 0.4 + angleOffset, length * 0.7, depth + 1, colorIndex + 1);
      }
    }

    class ParticleGalaxyPattern {
      constructor(ctx, width, height, palette) {
        this.ctx = ctx;
        this.width = width;
        this.height = height;
        this.palette = palette;
        this.particles = [];
        this.time = 0;
        this.centerX = width / 2;
        this.centerY = height / 2;
        this.density = 1;

        this.initParticles();
      }

      initParticles() {
        this.particles = [];
        const count = Math.floor(1000 * this.density);
        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const radius = Math.random() * Math.min(this.width, this.height) * 0.4;
          this.particles.push({
            angle: angle,
            radius: radius,
            speed: 0.001 + Math.random() * 0.002,
            size: Math.random() * 3 + 1,
            colorIndex: Math.floor(i / (count / 4))
          });
        }
      }

      update(speed, complexity) {
        this.time += 0.01 * speed;

        this.particles.forEach(p => {
          p.angle += p.speed * speed;
          p.radius += Math.sin(this.time + p.angle * 10) * 0.5 * complexity;
        });
      }

      draw() {
        this.ctx.globalCompositeOperation = 'lighter';

        this.particles.forEach(p => {
          const x = this.centerX + Math.cos(p.angle) * p.radius;
          const y = this.centerY + Math.sin(p.angle) * p.radius;

          const alpha = 1 - (p.radius / (Math.min(this.width, this.height) * 0.4));
          this.ctx.fillStyle = this.palette.getColor(p.colorIndex, alpha * 0.8);

          this.ctx.beginPath();
          this.ctx.arc(x, y, p.size, 0, Math.PI * 2);
          this.ctx.fill();

          // Glow effect
          this.ctx.shadowBlur = 10;
          this.ctx.shadowColor = this.palette.getColor(p.colorIndex, 0.5);
          this.ctx.fill();
          this.ctx.shadowBlur = 0;
        });

        this.ctx.globalCompositeOperation = 'source-over';
      }
    }

    class SacredGeometryPattern {
      constructor(ctx, width, height, palette) {
        this.ctx = ctx;
        this.width = width;
        this.height = height;
        this.palette = palette;
        this.time = 0;
      }

      update(speed, complexity) {
        this.time += 0.01 * speed;
      }

      draw() {
        const centerX = this.width / 2;
        const centerY = this.height / 2;
        const maxRadius = Math.min(this.width, this.height) * 0.4;

        this.ctx.globalCompositeOperation = 'lighter';

        // Flower of Life inspired pattern
        for (let layer = 0; layer < 5; layer++) {
          const circles = 6 + layer * 6;
          const radius = maxRadius * (layer + 1) / 5;

          for (let i = 0; i < circles; i++) {
            const angle = (i / circles) * Math.PI * 2 + this.time + layer;
            const x = centerX + Math.cos(angle) * radius * 0.5;
            const y = centerY + Math.sin(angle) * radius * 0.5;

            const innerRadius = radius * 0.15;
            const pulse = Math.sin(this.time * 2 + layer + i * 0.5) * 0.5 + 0.5;

            this.ctx.strokeStyle = this.palette.getColor(layer % 4, 0.4 + pulse * 0.3);
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(x, y, innerRadius, 0, Math.PI * 2);
            this.ctx.stroke();

            // Inner glow
            this.ctx.strokeStyle = this.palette.getColor((layer + 2) % 4, 0.2);
            this.ctx.lineWidth = 4;
            this.ctx.stroke();
          }
        }

        // Central mandala
        for (let i = 0; i < 12; i++) {
          const angle = (i / 12) * Math.PI * 2 + this.time;
          const length = maxRadius * 0.3;

          this.ctx.strokeStyle = this.palette.getColor(i % 4, 0.6);
          this.ctx.lineWidth = 3;
          this.ctx.beginPath();
          this.ctx.moveTo(centerX, centerY);
          this.ctx.lineTo(
            centerX + Math.cos(angle) * length,
            centerY + Math.sin(angle) * length
          );
          this.ctx.stroke();
        }

        this.ctx.globalCompositeOperation = 'source-over';
      }
    }

    class PlasmaWavesPattern {
      constructor(ctx, width, height, palette) {
        this.ctx = ctx;
        this.width = width;
        this.height = height;
        this.palette = palette;
        this.time = 0;
        this.complexity = 1;
      }

      update(speed, complexity) {
        this.time += 0.02 * speed;
        this.complexity = complexity;
      }

      draw() {
        const imageData = this.ctx.createImageData(this.width, this.height);
        const data = imageData.data;

        const scale = 50 / this.complexity;

        for (let y = 0; y < this.height; y += 4) {
          for (let x = 0; x < this.width; x += 4) {
            const value =
              Math.sin(x / scale + this.time) +
              Math.sin(y / scale + this.time) +
              Math.sin((x + y) / scale + this.time) +
              Math.sin(Math.sqrt(x * x + y * y) / scale + this.time);

            const normalized = (value + 4) / 8;
            const colorIndex = Math.floor(normalized * 4) % 4;
            const color = this.palette.getColor(colorIndex, 0.8);

            const rgb = this.hexToRgb(this.palette.toHex(color));

            for (let dy = 0; dy < 4; dy++) {
              for (let dx = 0; dx < 4; dx++) {
                if (x + dx < this.width && y + dy < this.height) {
                  const i = ((y + dy) * this.width + (x + dx)) * 4;
                  data[i] = rgb.r;
                  data[i + 1] = rgb.g;
                  data[i + 2] = rgb.b;
                  data[i + 3] = 255;
                }
              }
            }
          }
        }

        this.ctx.putImageData(imageData, 0, 0);
      }

      hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : { r: 0, g: 0, b: 0 };
      }
    }

    // ============================================================================
    // MAIN ART CONTROLLER
    // ============================================================================

    class GenerativeArtPlayground {
      constructor() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d', { alpha: false });
        this.resizeCanvas();

        this.patterns = [
          { name: 'FLOW FIELD', class: FlowFieldPattern, scheme: 'cosmic' },
          { name: 'FRACTAL TREE', class: FractalTreePattern, scheme: 'analogous' },
          { name: 'PARTICLE GALAXY', class: ParticleGalaxyPattern, scheme: 'vaporwave' },
          { name: 'SACRED GEOMETRY', class: SacredGeometryPattern, scheme: 'complementary' },
          { name: 'PLASMA WAVES', class: PlasmaWavesPattern, scheme: 'cyberpunk' }
        ];

        this.currentPatternIndex = 0;
        this.isAnimating = true;
        this.speed = 1;
        this.density = 1;
        this.complexity = 1;
        this.mouseX = 0;
        this.mouseY = 0;
        this.isMouseDown = false;

        this.fps = 60;
        this.frameCount = 0;
        this.lastFpsUpdate = Date.now();

        this.initPattern();
        this.setupEventListeners();
        this.updateUI();
        this.animate();
      }

      resizeCanvas() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
      }

      initPattern() {
        const patternInfo = this.patterns[this.currentPatternIndex];
        this.seed = Math.random();
        this.palette = new ColorPalette(null, patternInfo.scheme, this.seed);
        this.pattern = new patternInfo.class(
          this.ctx,
          this.canvas.width,
          this.canvas.height,
          this.palette
        );

        if (this.pattern.density !== undefined) {
          this.pattern.density = this.density;
          if (this.pattern.initParticles) {
            this.pattern.initParticles();
          }
        }

        this.clearCanvas();
      }

      clearCanvas() {
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      }

      setupEventListeners() {
        window.addEventListener('resize', () => {
          this.resizeCanvas();
          this.initPattern();
        });

        document.addEventListener('keydown', (e) => {
          switch(e.key.toLowerCase()) {
            case ' ':
              e.preventDefault();
              this.nextPattern();
              break;
            case 'r':
              this.randomize();
              break;
            case 'p':
              this.toggleAnimation();
              break;
            case 'e':
              this.exportImage();
              break;
          }
        });

        this.canvas.addEventListener('mousemove', (e) => {
          this.mouseX = e.clientX;
          this.mouseY = e.clientY;

          if (this.isMouseDown && this.pattern.particles) {
            this.spawnParticlesAtMouse();
          }
        });

        this.canvas.addEventListener('mousedown', (e) => {
          this.isMouseDown = true;
          this.mouseX = e.clientX;
          this.mouseY = e.clientY;
          this.createInteractionBurst();
        });

        this.canvas.addEventListener('mouseup', () => {
          this.isMouseDown = false;
        });

        this.canvas.addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.mouseX = e.touches[0].clientX;
          this.mouseY = e.touches[0].clientY;
          this.createInteractionBurst();
        });

        this.canvas.addEventListener('touchmove', (e) => {
          e.preventDefault();
          this.mouseX = e.touches[0].clientX;
          this.mouseY = e.touches[0].clientY;
        });
      }

      spawnParticlesAtMouse() {
        if (this.pattern.particles && Math.random() < 0.3) {
          const newParticles = Array(5).fill().map(() => ({
            x: this.mouseX + (Math.random() - 0.5) * 20,
            y: this.mouseY + (Math.random() - 0.5) * 20,
            vx: (Math.random() - 0.5) * 2,
            vy: (Math.random() - 0.5) * 2,
            life: Math.random(),
            colorIndex: Math.floor(Math.random() * 4)
          }));
          this.pattern.particles.push(...newParticles);
        }
      }

      createInteractionBurst() {
        this.ctx.globalCompositeOperation = 'lighter';
        for (let i = 0; i < 12; i++) {
          const angle = (i / 12) * Math.PI * 2;
          const distance = 30 + Math.random() * 20;
          const x = this.mouseX + Math.cos(angle) * distance;
          const y = this.mouseY + Math.sin(angle) * distance;

          this.ctx.fillStyle = this.palette.getColor(i % 4, 0.7);
          this.ctx.beginPath();
          this.ctx.arc(x, y, 8, 0, Math.PI * 2);
          this.ctx.fill();

          this.ctx.shadowBlur = 15;
          this.ctx.shadowColor = this.palette.getColor(i % 4, 0.8);
          this.ctx.fill();
        }
        this.ctx.shadowBlur = 0;
        this.ctx.globalCompositeOperation = 'source-over';
      }

      nextPattern() {
        this.currentPatternIndex = (this.currentPatternIndex + 1) % this.patterns.length;
        this.initPattern();
        this.updateUI();
      }

      randomize() {
        const schemes = ['analogous', 'complementary', 'triadic', 'tetradic',
                        'monochromatic', 'cosmic', 'vaporwave', 'cyberpunk'];
        const randomScheme = schemes[Math.floor(Math.random() * schemes.length)];
        this.palette = new ColorPalette(null, randomScheme, Math.random());
        this.pattern.palette = this.palette;
        this.clearCanvas();
        this.updateUI();
      }

      toggleAnimation() {
        this.isAnimating = !this.isAnimating;
        if (this.isAnimating) {
          this.animate();
        }
      }

      setSpeed(value) {
        this.speed = parseFloat(value);
        document.getElementById('speed-value').textContent = this.speed.toFixed(1);
      }

      setDensity(value) {
        this.density = parseFloat(value);
        document.getElementById('density-value').textContent = this.density.toFixed(1);
        if (this.pattern.density !== undefined) {
          this.pattern.density = this.density;
          if (this.pattern.initParticles) {
            this.pattern.initParticles();
          }
        }
      }

      setComplexity(value) {
        this.complexity = parseFloat(value);
        document.getElementById('complexity-value').textContent = this.complexity.toFixed(1);
      }

      exportImage() {
        const link = document.createElement('a');
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        link.download = `generative-art-${timestamp}.png`;
        link.href = this.canvas.toDataURL();
        link.click();
      }

      updateUI() {
        const patternInfo = this.patterns[this.currentPatternIndex];
        document.getElementById('pattern-name').textContent = patternInfo.name;
        document.getElementById('seed-code').textContent =
          `Seed: ${this.seed.toFixed(6)} | Scheme: ${this.palette.scheme.toUpperCase()}`;

        const paletteContainer = document.getElementById('color-palette');
        paletteContainer.innerHTML = '';

        this.palette.getAllColors().forEach((color, i) => {
          const hsla = this.palette.getColor(i);
          const hex = this.palette.toHex(hsla);

          const swatch = document.createElement('div');
          swatch.className = 'color-swatch';
          swatch.style.background = hsla;
          swatch.title = `${hsla}\n${hex}`;

          const info = document.createElement('div');
          info.className = 'color-info';
          info.textContent = hex;

          swatch.appendChild(info);
          paletteContainer.appendChild(swatch);

          swatch.addEventListener('click', () => {
            navigator.clipboard.writeText(hex);
            info.textContent = 'Copied!';
            setTimeout(() => { info.textContent = hex; }, 1000);
          });
        });
      }

      updateFPS() {
        this.frameCount++;
        const now = Date.now();
        if (now - this.lastFpsUpdate >= 1000) {
          this.fps = this.frameCount;
          this.frameCount = 0;
          this.lastFpsUpdate = now;
          document.getElementById('fps-counter').textContent = `FPS: ${this.fps}`;
        }
      }

      animate() {
        if (!this.isAnimating) return;

        // Trail effect for some patterns
        if (this.currentPatternIndex === 0 || this.currentPatternIndex === 2) {
          this.ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        } else {
          this.clearCanvas();
        }

        this.pattern.update(this.speed, this.complexity);
        this.pattern.draw();

        this.updateFPS();
        requestAnimationFrame(() => this.animate());
      }
    }

    // Initialize the art playground
    const art = new GenerativeArtPlayground();
  </script>
</body>
</html>
